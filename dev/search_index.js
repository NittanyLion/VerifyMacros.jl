var documenterSearchIndex = {"docs":
[{"location":"#VerifyMacros.jl","page":"Home","title":"VerifyMacros.jl","text":"Documentation for VerifyMacros.jl.\n\nVerifyMacros.jl is your toolkit for runtime verification with style. üíÖ\n\nStop writing boilerplate checks and manual error messages. Use VerifyMacros to assert conditions and get descriptive, color-coded error output that tells you exactly what went wrong.","category":"section"},{"location":"#Comparison-with-ArgCheck.jl","page":"Home","title":"üÜö Comparison with ArgCheck.jl","text":"You might know ArgCheck.jl, which is excellent for concise argument checking. Here's how VerifyMacros.jl differs:\n\nFeature ArgCheck.jl (@argcheck) VerifyMacros.jl (@verify...)\nPhilosophy Concise preconditions Descriptive, specific failure context\nError Type ArgumentError (mostly) TypeError, KeyError, DimensionMismatch, etc.\nMessage Generic or manual string Auto-generated, descriptive, and styled (colored)\nUsage @argcheck x > 0 @verifytype x Int or @verifykey d :id\nBest For Function preconditions Data validation, debugging complex state, helpful errors\n\nChoose VerifyMacros.jl when you want your users (or future you) to know exactly why a check failed without digging into the stack trace.","category":"section"},{"location":"#Installation","page":"Home","title":"üì¶ Installation","text":"using Pkg\nPkg.add(\"VerifyMacros\")","category":"section"},{"location":"#Usage","page":"Home","title":"üöÄ Usage","text":"","category":"section"},{"location":"#Single-Verifications","page":"Home","title":"üîç Single Verifications","text":"Validate types, keys, dimensions, and more.","category":"section"},{"location":"#Types-and-Structure","page":"Home","title":"Types & Structure","text":"using VerifyMacros\n\nx = 1.0\n@verifytype x Float64  # ‚úÖ Passes\n@verifytype x Int      # ‚ùå Throws: TypeError: x is of type Float64; was expecting a Int","category":"section"},{"location":"#Dictionaries-and-Properties","page":"Home","title":"Dictionaries & Properties","text":"d = Dict(:a => 1)\n@verifykey d :a        # ‚úÖ Passes\n@verifykey d :b        # ‚ùå Throws: KeyError: d lacks key :b\n\nstruct Obj; p; end\no = Obj(1)\n@verifyproperty o :p   # ‚úÖ Passes","category":"section"},{"location":"#Collections-and-Dimensions","page":"Home","title":"Collections & Dimensions","text":"A = [1, 2]\n@verifyaxes A (1:2,)   # ‚úÖ Passes\n@verifyin 1 A          # ‚úÖ Passes\n@verifylength A 2      # ‚úÖ Passes","category":"section"},{"location":"#Batch-Verifications","page":"Home","title":"üì¶ Batch Verifications","text":"Check everything at once. Clean and efficient.\n\n# Check multiple types\n@verifytypes (x, Float64) (1, Int)\n\n# Check multiple keys\n@verifykeys (d, :a) (d, :b)\n# OR shorthand for one dict:\n@verifykeys(d, :a, :b, :c)\n\n# Check multiple files\n@verifyisfiles (\"config.json\",) (\"data.csv\",)","category":"section"},{"location":"#Available-Macros","page":"Home","title":"üõ†Ô∏è Available Macros","text":"Macro Description\n@verifytype Check type of value (isa)\n@verifykey Check key in dictionary (haskey)\n@verifyproperty Check property of object (hasproperty)\n@verifyfield Check field of type (hasfield)\n@verifyin Check membership (in)\n@verifysupertype Check subtype relation (<:)\n@verifyaxes Check array axes\n@verifysize Check array size\n@verifylength Check collection length\n@verifyequal Check equality (==)\n@verifyisfile Check file existence\n@verifyisdir Check directory existence\n@verifytrue Generic assertion\n\nAll macros have plural versions (e.g., @verifytypes) for batch checking.","category":"section"},{"location":"#Reference","page":"Home","title":"Reference","text":"","category":"section"},{"location":"#The-Meta-Macro:-@verify","page":"Home","title":"üõ†Ô∏è The Meta-Macro: @verify","text":"If you prefer a single entry point, use @verify. The first argument is a symbol (e.g., :type, :keys) which determines which check to run.\n\n@verify :type x Float64      # expands to @verifytype x Float64\n@verify :keys d :a :b        # expands to @verifykeys d :a :b\n@verify :true 1 < 2          # expands to @verifytrue 1 < 2","category":"section"},{"location":"#VerifyMacros.@define_verification-NTuple{4, Any}","page":"Home","title":"VerifyMacros.@define_verification","text":"@define_verification(Singular, Plural, FunctionName, NArgs)\n\nGenerates the verification macros:\n\n@Singular: The main macro (e.g., @verifytype).\n@_Singular_internal: Internal macro for batch processing.\n@Plural: Batch verification macro (e.g., @verifytypes).\n\nArguments:\n\nSingular: Name of the singular macro (symbol).\nPlural: Name of the plural macro (symbol).\nFunctionName: Name of the backend function to call (symbol).\nNArgs: Number of arguments to verify (1 or 2).\n\nThe backend function is expected to have the signature:\n\nfunc(val, expected, name, location) for NArgs = 2\nfunc(val, name, location) for NArgs = 1\n\n\n\n\n\n","category":"macro"},{"location":"#VerifyMacros.@verify-Tuple{Any, Vararg{Any}}","page":"Home","title":"VerifyMacros.@verify","text":"@verify :action args...\n\nGeneral purpose verification macro that delegates to specific @verify... macros. The first argument must be a symbol (e.g., :type, :keys) which is appended to \"verify\" to determine the target macro.\n\nExample:     @verify :type x Int expands to @verifytype x Int     @verify :keys d :a :b expands to @verifykeys d :a :b\n\n\n\n\n\n","category":"macro"},{"location":"#VerifyMacros.@verifykeys-Tuple","page":"Home","title":"VerifyMacros.@verifykeys","text":"@verifykeys((dict1, key1), (dict2, key2), ...)\n@verifykeys(dict, key1, key2, ...)\n\nBatch verify multiple key checks. Usage 1: Each argument is a tuple of (dict, key[, name]). Equivalent to multiple @verifykey calls. Usage 2: First argument is the dictionary, subsequent arguments are keys. Verify that dict contains all specified keys.\n\n\n\n\n\n","category":"macro"}]
}
